#!/usr/bin/env python

import sys
import os
import string
import re

Chunk_Header_Pat = re.compile('@@ -([0-9]+)(?:,([0-9]+))? \+([0-9]+)(?:,([0-9]+))? @@')

class struct:
  pass
  
def parse_chunk_header(s):
  origL, del_N, newL, add_N = Chunk_Header_Pat.match(s).groups()
  if del_N is None:
    del_N = 1
  if add_N is None:
    add_N = 1
    
  return map(int,(origL, del_N, newL, add_N))

def get_initial_version(first_rev,fn):
  lines = []
  file_started_FL = False
  for line in os.popen('git-show %s %s'%(first_rev,fn)):
    if file_started_FL:
      assert line[0]=='+',("don't recognize format",line)
      lines.append(line[1:]) # take out the leading '+'
    else:
      if line.startswith('@@ -0,0 '):
        file_started_FL=True
  return lines
  
def find_index(ALL_LINES,L):
  i=0
  while L:
    if i==len(ALL_LINES):               # appending to the end
      return i
    if ALL_LINES[i].endrev==None:       # line that has not been deleted
      L-=1
    i+=1
  # ffwd through deleted lines
  while i<len(ALL_LINES) and ALL_LINES[i].endrev<>None:
    i+=1
  return i
  
def find_next_alive(ALL_LINES,i):
  while 1:
    if ALL_LINES[i].endrev==None:
      return i
    i+=1
    
def print_so_far(ALL_LINES):
  #lastbegrev = None
  for line in ALL_LINES:
    #if line.begrev == lastbegrev:
    #  beg = '   ^    '
    #else:
    #  beg = line.begrev[:8]
    #lastbegrev = line.begrev
    beg = line.begrev[:8]
    end = '    ' if line.endrev is None else line.endrev[:8]
      
    print '%8s %8s:'%(beg,end),line.text,
  print 
    
def main():
  V=0
  
  fn = sys.argv[1]
  
  # get all revisions
  revs = map(string.strip,os.popen('git-rev-list HEAD -- %s'%fn).readlines())
  revs.insert(0,'HEAD')
  
  # initial version
  ALL_LINES=[]
  for line in get_initial_version(revs[-1],fn):
    x = struct()
    x.text    = line
    x.begrev  = revs[-1]
    x.endrev  = None
    ALL_LINES.append(x)  
  
  if V:
    print_so_far(ALL_LINES)
  
  # process all the revisions
  origL, del_N, newL, add_N = 0,0,0,0
  for r in range(len(revs)-1,0,-1):
    
    cmd = 'git-diff -U0 %s %s %s'%(revs[r],revs[r-1],fn)
    
    if V:
      print '[cmd]',cmd
      print
    
    for line_no,line in enumerate(os.popen(cmd)):
    
        if line_no<4:                 # SKIP OVER HEADER
          continue
         
        if V: 
          print '[line]',repr(line)
        
        if line.startswith('@@'):     # RECEIVED A NEW CHUNK!
        
          origL, del_N, newL, add_N = parse_chunk_header(line)
          all_index = None
          if V:
            print 'chunk',origL,del_N,newL,add_N
          
        elif del_N:                   # PROCESSING DELETED LINES
        
          assert line.startswith('-'),line
          
          if all_index is None:       # find index in ALL_LINES for origL
            all_index = find_index(ALL_LINES, origL-1)
          else:
            all_index = find_next_alive(ALL_LINES, all_index)
           
          #if V: 
          #  print 'DEL origL=%d del_N=%d all_index=%d text=%r'%(origL,del_N,all_index,ALL_LINES[all_index].text)
              
          ALL_LINES[all_index].endrev = revs[r-1]
          
          del_N -= 1
          if del_N == 0:
            all_index = None
          
        elif add_N:                   # PROCESSING ADDED LINES
        
          assert line.startswith('+'),line
          if all_index is None:
            all_index = find_index(ALL_LINES, newL-1)
          else:
            all_index += 1
                      
          x = struct()
          x.text = line[1:]
          x.begrev = revs[r-1]
          x.endrev = None
          
          ALL_LINES.insert(all_index, x)
          
          add_N -= 1
          if add_N == 0:
            all_index = None
          
        else:
          assert 0, "shouldn't reach here unless misparsed diff output"
        
    if V:
      print
      print_so_far(ALL_LINES)
      
  print_so_far(ALL_LINES)
  
if __name__=='__main__':
  main()
