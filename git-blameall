#!/usr/bin/env python

import sys
import os
import string
import re

Chunk_Header_Pat = re.compile('@@ -([0-9]+)(?:,([0-9]+))? \+([0-9]+)(?:,([0-9]+))? @@')

class struct:
  pass
  
def parse_chunk_header(s):
  origL, del_N, newL, add_N = Chunk_Header_Pat.match(s).groups()
  if del_N is None:
    del_N = 1
  if add_N is None:
    add_N = 1
    
  return map(int,(origL, del_N, newL, add_N))

def get_initial_version(first_rev,fn):
  lines = []
  file_started_FL = False
  for line in os.popen('git-show %s %s'%(first_rev,fn)):
    if line=='\ No newline at end of file\n':
        continue
    if file_started_FL:
      assert line[0]=='+',("don't recognize format",line)
      lines.append(line[1:]) # take out the leading '+'
    else:
      if line.startswith('@@ -0,0 '):
        file_started_FL=True
  return lines
  
def find_index(ALL_LINES,L,current_rev=None):
  i=0
  while L:
    if i==len(ALL_LINES):               # appending to the end
      return i
    if ALL_LINES[i].endrev == None: # this line is still alive
      if ALL_LINES[i].begrev==current_rev: # this line was inserted during the current revision, doesn't count
        pass
      else:
        L-=1 # count the line
    elif ALL_LINES[i].endrev == current_rev: # still count the line, it was erased during the current revision
      L-=1
    i+=1
  # ffwd through deleted lines
  while i<len(ALL_LINES) and ALL_LINES[i].endrev<>None:
    i+=1
  return i
  
def find_next_alive(ALL_LINES,i):
  while 1:
    if ALL_LINES[i].endrev==None:
      return i
    i+=1
    

def print_so_far(ALL_LINES,revs):
  head_rev = struct()
  #head_rev.hash = '  HEAD  '
  head_rev.hash = '        '
  head_rev.date = '          '
  head_rev.author = '        '
  i=0
  for line in ALL_LINES:
    beg = revs[line.begrev]
    end = revs[line.endrev] if line.endrev is not None else head_rev
    #if line.endrev is None:
    #  i+=1
    #  print '%3d'%i,
    #else:
    #  print '   ',
    #print '%s %s %s %s %s %s:'%(beg.hash[:8],end.hash[:8],beg.date,end.date,beg.author,end.author),line.text,
    #print '(%s %s %s)(%s %s %s)'%(beg.hash[:8],beg.date,beg.author,end.hash[:8],end.date,end.author),line.text,
    #print '%s (%s %s) %s (%s %s)'%(beg.hash[:8],beg.author,beg.date,end.hash[:8],end.author,end.date),line.text,
    #print '%s (%s %s) %s (%s %s)'%(beg.hash[:8],beg.author,beg.date,end.hash[:8],end.author,end.date),line.text,
    if line.endrev is not None:
      print '-%s (%s %s) +%s (%s %s)'%(end.hash[:8],end.author,end.date,beg.hash[:8],beg.author,beg.date),line.text,
    else:
      print ' %s  %s %s  +%s (%s %s)'%(end.hash[:8],end.author,end.date,beg.hash[:8],beg.author,beg.date),line.text,
  print 
    
def main():
  V=0
  
  fn = sys.argv[1]
  
  hashes      = os.popen('git-rev-list HEAD -- %s'%fn).readlines() # GET ALL REVISIONS
  date_author = os.popen('git-log --format="%%ad %%cn" --date=short %s'%fn).readlines() # GET REVISION INFO  
  assert len(hashes)==len(date_author), ('mismatch between output of git-rev-list and git-log', hashes, date_author)
  
  revs = []
  for hash, date_au in zip(hashes,date_author):
    x = struct()
    x.hash = hash.strip()
    x.date, x.author = date_au.split(' ',1)
    x.author = x.author.strip()
    revs.append(x)
    
  #max_author_len = max([len(x.author) for x in revs])
  #forced_author_len = min(8,max_author_len)
  
  forced_author_len = 8
  for x in revs:
    if len(x.author) > forced_author_len:
      x.author = x.author[:forced_author_len-1]+'.'
    else:
      #x.author = x.author.center(forced_author_len)
      x.author = x.author.ljust(forced_author_len)
  
  ALL_LINES=[]                        # INITIAL VERSION
  for line in get_initial_version(revs[-1].hash,fn):
    x = struct()
    x.text    = line
    x.begrev  = len(revs)-1
    x.endrev  = None
    ALL_LINES.append(x)  
  
  if V:
    print_so_far(ALL_LINES,revs)
  
  # process all the revisions
  origL, del_N, newL, add_N = 0,0,0,0
  for r in range(len(revs)-1,0,-1):
    
    cmd = 'git-diff -U0 %s %s %s'%(revs[r].hash,revs[r-1].hash,fn)
    
    if V:
      print '[cmd]',cmd
      print
    
    for line_no,line in enumerate(os.popen(cmd)):
    
        if line_no<4:                 # SKIP OVER HEADER
          continue
         
        if line=='\ No newline at end of file\n':
            continue
            
        if V: 
          print '[line]',repr(line)
        
        if line.startswith('@@'):     # RECEIVED A NEW CHUNK!
        
          origL, del_N, newL, add_N = parse_chunk_header(line)
          all_index = None
          if V:
            print 'chunk',origL,del_N,newL,add_N
          
        elif del_N:                   # PROCESSING DELETED LINES
        
          assert line.startswith('-'),line
          
          if all_index is None:       # find index in ALL_LINES for origL
            all_index = find_index(ALL_LINES, origL-1, current_rev=r-1)
          else:
            all_index = find_next_alive(ALL_LINES, all_index)
           
          #if V: 
          #  print 'DEL origL=%d del_N=%d all_index=%d text=%r'%(origL,del_N,all_index,ALL_LINES[all_index].text)
              
          assert ALL_LINES[all_index].text == line[1:], \
            ("diff processing screwed up, marking the wrong deletion line",ALL_LINES[all_index].text,line,all_index)
          ALL_LINES[all_index].endrev = r-1
          
          del_N -= 1
          if del_N == 0:
            all_index = None
          
        elif add_N:                   # PROCESSING ADDED LINES
        
          assert line.startswith('+'),line
          if all_index is None:
            all_index = find_index(ALL_LINES, newL-1)
          else:
            all_index += 1
                      
          x = struct()
          x.text = line[1:]
          x.begrev = r-1
          x.endrev = None
          
          ALL_LINES.insert(all_index, x)
          
          add_N -= 1
          if add_N == 0:
            all_index = None
          
        else:
          assert 0, "shouldn't reach here unless misparsed diff output"
        
    if V:
      print
      print_so_far(ALL_LINES,revs)
      
  print_so_far(ALL_LINES,revs)
  
if __name__=='__main__':
  main()
